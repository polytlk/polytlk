/**
 * Generated by orval v7.1.0 üç∫
 * Do not edit manually.
 * django-allauth: Headless API
 * OpenAPI spec version: 1
 */
import { z as zod } from 'zod';

/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const postAllauthClientV1AuthLoginParams = zod.object({
  client: zod.enum(['app', 'browser']),
});

export const postAllauthClientV1AuthLoginBody = zod
  .object({
    username: zod.string(),
  })
  .or(
    zod.object({
      email: zod.string(),
    })
  );

export const postAllauthClientV1AuthLoginResponse = zod.object({
  status: zod.number(),
  data: zod.object({
    user: zod.object({
      id: zod.number().or(zod.string()).optional(),
      display: zod.string().optional(),
      has_usable_password: zod.boolean().optional(),
      email: zod.string().optional(),
      username: zod.string().optional(),
    }),
    methods: zod.array(
      zod
        .object({
          method: zod.enum(['password']),
          at: zod.number(),
          email: zod.string().optional(),
          username: zod.string().optional(),
        })
        .or(
          zod.object({
            method: zod.enum(['password']),
            at: zod.number(),
            reauthenticated: zod.literal(true),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['socialaccount']),
            at: zod.number(),
            provider: zod.string(),
            uid: zod.string(),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['mfa']),
            at: zod.number(),
            type: zod.enum(['recovery_codes', 'totp']),
            reauthenticated: zod.boolean().optional(),
          })
        )
    ),
  }),
  meta: zod
    .object({
      session_token: zod.string().optional(),
      access_token: zod.string().optional(),
    })
    .and(
      zod.object({
        is_authenticated: zod.boolean(),
      })
    ),
});

/**
 * Whether or not `username`, `email`, or both are required depends on
the configuration of django-allauth. Additionally, if a custom signup
form is used there may be other custom properties required.

 * @summary Signup
 */
export const postAllauthClientV1AuthSignupParams = zod.object({
  client: zod.enum(['app', 'browser']),
});

export const postAllauthClientV1AuthSignupBody = zod.object({
  email: zod.string().optional(),
  username: zod.string().optional(),
  password: zod.string(),
});

export const postAllauthClientV1AuthSignupResponse = zod.object({
  status: zod.number(),
  data: zod.object({
    user: zod.object({
      id: zod.number().or(zod.string()).optional(),
      display: zod.string().optional(),
      has_usable_password: zod.boolean().optional(),
      email: zod.string().optional(),
      username: zod.string().optional(),
    }),
    methods: zod.array(
      zod
        .object({
          method: zod.enum(['password']),
          at: zod.number(),
          email: zod.string().optional(),
          username: zod.string().optional(),
        })
        .or(
          zod.object({
            method: zod.enum(['password']),
            at: zod.number(),
            reauthenticated: zod.literal(true),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['socialaccount']),
            at: zod.number(),
            provider: zod.string(),
            uid: zod.string(),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['mfa']),
            at: zod.number(),
            type: zod.enum(['recovery_codes', 'totp']),
            reauthenticated: zod.boolean().optional(),
          })
        )
    ),
  }),
  meta: zod
    .object({
      session_token: zod.string().optional(),
      access_token: zod.string().optional(),
    })
    .and(
      zod.object({
        is_authenticated: zod.boolean(),
      })
    ),
});

/**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getAllauthClientV1AuthEmailVerifyParams = zod.object({
  client: zod.enum(['app', 'browser']),
});

export const getAllauthClientV1AuthEmailVerifyHeader = zod.object({
  'X-Email-Verification-Key': zod.string(),
});

export const getAllauthClientV1AuthEmailVerifyResponse = zod.object({
  status: zod.number(),
  data: zod.object({
    email: zod.string(),
    user: zod.object({
      id: zod.number().or(zod.string()).optional(),
      display: zod.string().optional(),
      has_usable_password: zod.boolean().optional(),
      email: zod.string().optional(),
      username: zod.string().optional(),
    }),
  }),
  meta: zod.object({
    is_authenticating: zod.boolean(),
  }),
});

/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

 * @summary Verify an email
 */
export const postAllauthClientV1AuthEmailVerifyParams = zod.object({
  client: zod.enum(['app', 'browser']),
});

export const postAllauthClientV1AuthEmailVerifyHeader = zod.object({
  'X-Session-Token': zod.string().optional(),
});

export const postAllauthClientV1AuthEmailVerifyBody = zod.object({
  key: zod.string(),
});

export const postAllauthClientV1AuthEmailVerifyResponse = zod.object({
  status: zod.number(),
  data: zod.object({
    user: zod.object({
      id: zod.number().or(zod.string()).optional(),
      display: zod.string().optional(),
      has_usable_password: zod.boolean().optional(),
      email: zod.string().optional(),
      username: zod.string().optional(),
    }),
    methods: zod.array(
      zod
        .object({
          method: zod.enum(['password']),
          at: zod.number(),
          email: zod.string().optional(),
          username: zod.string().optional(),
        })
        .or(
          zod.object({
            method: zod.enum(['password']),
            at: zod.number(),
            reauthenticated: zod.literal(true),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['socialaccount']),
            at: zod.number(),
            provider: zod.string(),
            uid: zod.string(),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['mfa']),
            at: zod.number(),
            type: zod.enum(['recovery_codes', 'totp']),
            reauthenticated: zod.boolean().optional(),
          })
        )
    ),
  }),
  meta: zod
    .object({
      session_token: zod.string().optional(),
      access_token: zod.string().optional(),
    })
    .and(
      zod.object({
        is_authenticated: zod.boolean(),
      })
    ),
});

/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const postAllauthClientV1AuthReauthenticateParams = zod.object({
  client: zod.enum(['app', 'browser']),
});

export const postAllauthClientV1AuthReauthenticateHeader = zod.object({
  'X-Session-Token': zod.string().optional(),
});

export const postAllauthClientV1AuthReauthenticateBody = zod.object({
  password: zod.string(),
});

export const postAllauthClientV1AuthReauthenticateResponse = zod.object({
  status: zod.number(),
  data: zod.object({
    user: zod.object({
      id: zod.number().or(zod.string()).optional(),
      display: zod.string().optional(),
      has_usable_password: zod.boolean().optional(),
      email: zod.string().optional(),
      username: zod.string().optional(),
    }),
    methods: zod.array(
      zod
        .object({
          method: zod.enum(['password']),
          at: zod.number(),
          email: zod.string().optional(),
          username: zod.string().optional(),
        })
        .or(
          zod.object({
            method: zod.enum(['password']),
            at: zod.number(),
            reauthenticated: zod.literal(true),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['socialaccount']),
            at: zod.number(),
            provider: zod.string(),
            uid: zod.string(),
          })
        )
        .or(
          zod.object({
            method: zod.enum(['mfa']),
            at: zod.number(),
            type: zod.enum(['recovery_codes', 'totp']),
            reauthenticated: zod.boolean().optional(),
          })
        )
    ),
  }),
  meta: zod
    .object({
      session_token: zod.string().optional(),
      access_token: zod.string().optional(),
    })
    .and(
      zod.object({
        is_authenticated: zod.boolean(),
      })
    ),
});
